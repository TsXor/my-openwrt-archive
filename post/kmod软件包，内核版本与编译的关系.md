### 省流的简单解释 ~~（也不是那么省流）~~  
1. 名字**开头带kmod**的插件/软件包都依赖特定版本的内核，**内核版本不对装不上去**  
2. 内核版本是一个md5值，**在编译的时候会自动生成**  
3. ~~（终极哞）~~ 编译的时候由于内核文件发生变化以及编译配置与官方不同，**内核版本一般都不同于官方，因此无法安装官方源的kmod包**  
4. **内核版本可以通过一些特殊操作固定为特定的值**，将内核版本固定为与官方镜像相同，你编译出的固件就可以安装官方的kmod包。但是如果你的编译配置与官方差别太大，或者加入了新的型号的路由器的支持，又或者你给官方的某个底层代码打了补丁，总之就是**变化太大，安装官方源的kmod包虽然不会报依赖错误，但是会安装失败，严重时路由器会崩溃失联数分钟**  
### 不是太必要的额外解释  
上述的简要解释只说明了`openwrt版本管理系统（起作用的主要是opkg）`这一层的事。要想解释的完全，需要涉及`linux内核版本号`与`linux内核模块`这两个概念。  
- `linux内核版本号`：和正常的软件版本号一样，如`4.9`、`5.14`。openwrt的内核版本管理精确到md5，但是“linux内核版本号”是人制定的。你下载openwrt的源码来编译，编译时和官方用了不同的选项，编译出来的内核“linux版本号”和官方固件是一样的，但是由于编译选项的改变，最后编译出的内核本身有了变化，md5不同，openwrt的内核版本就不一样。  
- `linux内核模块`：openwrt的“kmod软件包”只是“linux内核模块”的一个上层包装。“linux内核模块”本身是一个后缀为`.ko`的文件，可以通过`insmod`命令加载。“linux内核模块”自己也带版本验证，但是它认的是“linux内核版本号”。然而，如果对内核大改，即使通过了模块自带的版本验证，模块也可能无法正常工作。  

因此，如果你对openwrt的源码变化太大，即使你固定了openwrt的内核版本，通过了opkg层的版本验证，然后又通过了linux内核模块自身的版本验证，加载了内核模块，内核模块也会出问题。而linux内核出了问题会直接导致系统崩溃。
### 为什么这么多大佬分别编译“纯净版”、“带插件版”和“高大全版”？  
有的是因为路由器空间本身就小，需要省空间，否则路由器的闪存装不下。  
有的是因为他们只知道“我自己的编译的版本带不上官方插件，只能编译的时候安装”。这种想法是错误的。不想编在固件里的模块可以选择模块化编译成ipk，然后上传到github，osdn，sourceforge这些地方（相当于自建软件源），再修改固件中的软件源即可。  
你问有没有实践？本仓库就兼做软件源。
### 一些注释
这些基本概念如果当场解释，会使叙述偏题，故作为注释列在这里。  
- **md5是啥？**  
  它就是一个算法，你扔进去一个文件，就会出来一串定长的字母和数字，每个文件都对应一串惟一的字母与数字，而且目前没有方法单凭md5值反推出文件本身。你可以这么理解：**文件是身份证上的头像，md5是身份证号。**  
  网上的“md5解密”的原理就类似用身份证号查你头像，不是因为你身份证号里有你头像，而是因为我有一堆身份证，我看看我有的身份证里有没有一个是你的号，有的话再看这个身份证的头像。  
  
- **为什么把软件包在编译时直接加入固件中比编译成ipk再安装省空间？**  
  编译时加入，安装的文件会和其他系统文件一起用`squashfs`压缩打包；而上传ipk安装，安装的文件会被`ubifs`透明压缩。`squashfs`由于是提前打包而成，制作过程中cpu资源和时间都充足，所以主要追求压缩效果；`ubifs`由于是透明的即时压缩，需要使用速度更快、cpu占用更小的压缩算法，而相对的压缩效果就差一些，不如squashfs省空间。  
  形象的比喻，`squashfs`的压缩就像是用一个大铁块使劲压好几下，累人费时间，但是效果更好；`ubifs`的压缩就像是直接踩一脚，省力且快，但是效果比较差。
  
- **我把这么多ipk放到这些平台上，他们会不会查我水表啊？**  
  不会，因为即使模块化编译所有内核模块，**空间占用也不过20M，比一个本子还小。** 用github当图床的都大有人在，与他们相比这点东西真的不算啥。
